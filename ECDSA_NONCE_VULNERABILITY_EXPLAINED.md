# ECDSA Hardcoded Nonce Vulnerability - Detailed Explanation

## Vulnerability Location

**File:** `src/signing/mod.rs`
**Lines:** 260-263
**Function:** `create_ecdsa_signature_with_signing_key()`

---

## 1. What is ECDSA Signing?

ECDSA (Elliptic Curve Digital Signature Algorithm) is the cryptographic algorithm used to sign Bitcoin and Ethereum transactions. It creates a signature `(r, s)` that proves you own the private key without revealing it.

### The ECDSA Signing Process

```
1. Pick a RANDOM nonce k (must be unique for every signature!)
2. Calculate R = k × G  (multiply generator point G by nonce k)
3. r = x-coordinate of R
4. s = k⁻¹ × (z + r × x) mod n

Where:
- k = random nonce (MUST be unique per signature)
- G = generator point of the elliptic curve
- z = hash of the message being signed
- x = private key (the secret we're protecting)
- n = order of the curve (a large prime number)
- r, s = the two components of the signature
```

**Critical Security Requirement:** The nonce `k` MUST be:
- Random (unpredictable)
- Unique (never reused)
- Secret (not disclosed)

---

## 2. What's Happening in This Code?

### The Vulnerable Code

```rust
// src/signing/mod.rs:250-298

pub fn create_ecdsa_signature_with_signing_key(
    &self,
    message: &Message,
    signing_key: &SecretKey,
) -> Result<RecoverableSignature> {
    let sk = signing_key;
    let secp = Secp256k1::new();

    // ⚠️ LINE 260-261: THE VULNERABILITY - k is HARDCODED, not random!
    let k_bytes = [0x42u8; 32];  // k = 0x424242...42 (same every time!)
    let sec_nonce =
        SecretKey::from_slice(&k_bytes).map_err(|e| anyhow!("invalid nonce slice: {}", e))?;

    // Line 265-266: R = k × G (R is always the same because k is always the same)
    let r = PublicKey::from_secret_key(&secp, &sec_nonce);
    let rser = r.serialize_uncompressed();

    // ... extracting r value ...

    // Line 278-279: z = message hash
    let z = BigUint::from_bytes_be(message.as_ref());

    // Line 281-283: x = private key
    let sk_bytes = sk.secret_bytes();
    let x = BigUint::from_bytes_be(&sk_bytes);

    // Line 292-295: k⁻¹ mod n
    let k_inv = BigUint::from_bytes_be(&k_bytes)
        .modinv(&n)
        .ok_or_else(|| anyhow!("nonce not invertible"))?;

    // Line 297-298: s = k⁻¹ × (z + r × x) mod n
    let s = (&k_inv * (&z + (&r * &x) % &n)) % &n;

    // ... build signature (r, s) ...
}
```

### The Problem

The nonce `k` is hardcoded as:
```rust
let k_bytes = [0x42u8; 32];
```

This means `k` = `0x4242424242424242424242424242424242424242424242424242424242424242`

**Every single signature uses this exact same value for k.**

---

## 3. Why Is This Catastrophic?

### Mathematical Attack Explanation

When you sign **two different messages** with the **same nonce k**:

#### Signature 1 (for message with hash z₁):
```
R = k × G
r = x-coordinate of R        ← SAME r (because k is same)
s₁ = k⁻¹ × (z₁ + r × x) mod n
```

#### Signature 2 (for message with hash z₂):
```
R = k × G
r = x-coordinate of R        ← SAME r (because k is same)
s₂ = k⁻¹ × (z₂ + r × x) mod n
```

**Key observation:** Both signatures have the **same r value** because k is identical.

### The Attack

An attacker who observes both signatures `(r, s₁)` and `(r, s₂)` can do the following:

#### Step 1: Recover the nonce k

```
s₁ = k⁻¹ × (z₁ + r × x) mod n
s₂ = k⁻¹ × (z₂ + r × x) mod n

Subtract the equations:
s₁ - s₂ = k⁻¹ × (z₁ + r × x) - k⁻¹ × (z₂ + r × x)
s₁ - s₂ = k⁻¹ × [(z₁ + r × x) - (z₂ + r × x)]
s₁ - s₂ = k⁻¹ × (z₁ - z₂)

Solve for k:
k = (z₁ - z₂) × (s₁ - s₂)⁻¹ mod n
```

**The attacker now knows k!**

#### Step 2: Recover the private key x

Using either signature equation:
```
s₁ = k⁻¹ × (z₁ + r × x) mod n

Rearrange:
s₁ × k = z₁ + r × x mod n
r × x = s₁ × k - z₁ mod n
x = (s₁ × k - z₁) × r⁻¹ mod n
```

**The attacker now has the PRIVATE KEY!**

---

## 4. Concrete Example

### Scenario

The MPC network signs two transactions:

#### Transaction 1: Send 1 BTC to Alice
```
Message hash (z₁) = 0xabc123def456...
Signature: (r, s₁)
  r  = 0x7d8e9f1a2b3c... (derived from k × G)
  s₁ = 0x1234567890ab...
```

#### Transaction 2: Send 0.5 BTC to Bob
```
Message hash (z₂) = 0x789xyz123456...
Signature: (r, s₂)
  r  = 0x7d8e9f1a2b3c... (SAME r! Because k is the same)
  s₂ = 0xfedcba098765...
```

### Attack Execution

An attacker sees both transactions on the blockchain and notices **r is identical**.

```python
# Attacker's calculation (pseudocode)

# Known values (all public on blockchain)
z1 = 0xabc123def456...  # hash of transaction 1
z2 = 0x789xyz123456...  # hash of transaction 2
r  = 0x7d8e9f1a2b3c...  # same in both signatures
s1 = 0x1234567890ab...  # s from signature 1
s2 = 0xfedcba098765...  # s from signature 2
n  = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141  # curve order

# Step 1: Recover nonce k
k = ((z1 - z2) * mod_inverse(s1 - s2, n)) % n

# Step 2: Recover private key x
x = ((s1 * k - z1) * mod_inverse(r, n)) % n

# x is now the PRIVATE KEY!
# Attacker can sign any transaction and steal ALL funds
```

---

## 5. Proof That This Code Is Actively Used

### Call Path Analysis

```
User initiates transaction
        │
        ▼
sign_bitcoin_transaction()          [src/signing/chains/bitcoin.rs:96]
        │
        ▼
    for each input:
        │
        ▼
    create_ecdsa_signature_with_signing_key()   [src/signing/mod.rs:250]
        │
        ▼
    k_bytes = [0x42u8; 32]          ← HARDCODED NONCE USED HERE
        │
        ▼
    Signature (r, s) created with fixed k
```

### Actual Code References

**Bitcoin signing** - `src/signing/chains/bitcoin.rs:335-337`:
```rust
for (i, digest) in digests.iter().enumerate() {
    let msg = Message::from_digest_slice(digest)?;
    let sig = self.create_ecdsa_signature_with_signing_key(&msg, &signing_key)?;
    // ...
}
```

**Ethereum signing** - `src/signing/chains/ethereum.rs:945`:
```rust
pub fn create_ecdsa_signature_with_key(...) -> Result<RecoverableSignature> {
    self.create_ecdsa_signature_with_signing_key(message, signing_key)
}
```

**Contract signing** - `src/signing/chains/ethereum.rs:954`:
```rust
pub fn create_ecdsa_signature_with_key_contract(...) -> Result<RecoverableSignature> {
    self.create_ecdsa_signature_with_signing_key(message, signing_key)
}
```

**Every Bitcoin and Ethereum transaction signed by this system uses the hardcoded nonce.**

---

## 6. Historical Precedents

This exact vulnerability has been exploited multiple times in the real world:

### Sony PlayStation 3 Hack (2010)
- Sony used a fixed nonce (`k = 4`) for signing PS3 game software
- Hackers extracted Sony's private signing key
- This allowed running unsigned/pirated software on PS3
- Sony had to recall consoles and faced massive security breach

### Android Bitcoin Wallet Vulnerability (2013)
- Android's `SecureRandom` had weak entropy on some devices
- This caused nonce reuse in Bitcoin wallet apps
- Attackers monitored the blockchain for signatures with matching `r` values
- Thousands of dollars in Bitcoin were stolen

### Blockchain.info Vulnerability (2014)
- A bug caused nonce reuse in their signing implementation
- Attackers extracted private keys and stole funds

---

## 7. Severity Assessment

| Criteria | Assessment |
|----------|------------|
| **Is the vulnerable code present?** | ✅ YES - `src/signing/mod.rs:260-263` |
| **Is it actively used?** | ✅ YES - All BTC/ETH signatures go through this function |
| **Is the attack mathematically valid?** | ✅ YES - Standard ECDSA nonce reuse attack |
| **How many signatures needed to exploit?** | Only **2 signatures** |
| **What can attacker gain?** | Complete **private key** |
| **Impact?** | **Total fund theft** - attacker controls the wallet |

### CVSS Score: 10.0 (Critical)

- **Attack Vector:** Network (signatures are public on blockchain)
- **Attack Complexity:** Low (simple math, tools readily available)
- **Privileges Required:** None
- **User Interaction:** None
- **Impact:** Complete compromise of confidentiality (private key stolen)

---

## 8. How to Fix This

### Correct Implementation

The nonce `k` should be generated using one of these secure methods:

#### Option 1: RFC 6979 Deterministic Nonce (Recommended)
```rust
// Use deterministic nonce derived from private key + message
// This is reproducible but unique per message
use secp256k1::ecdsa::sign;

let signature = secp.sign_ecdsa(&message, &secret_key);
// The secp256k1 library handles RFC 6979 internally
```

#### Option 2: Cryptographically Secure Random Nonce
```rust
use rand::rngs::OsRng;
use rand::RngCore;

let mut k_bytes = [0u8; 32];
OsRng.fill_bytes(&mut k_bytes);  // Cryptographically secure random
```

### Why RFC 6979 is Preferred
- Deterministic: Same input always produces same nonce
- Unique: Different messages produce different nonces
- No random number generator needed (avoids RNG bugs)
- Widely audited and proven secure

---

## 9. Conclusion

**This is a real, critical vulnerability.**

The code at `src/signing/mod.rs:260-263` uses a hardcoded nonce value `0x424242...42` for all ECDSA signatures. This is a textbook cryptographic failure that allows:

1. Any observer to extract the private key after seeing just 2 signatures
2. Complete theft of all funds controlled by the MPC network
3. No special access or privileges required - just observe the public blockchain

**This code should never be used in production with real cryptocurrency.**

---

## 10. References

- [ECDSA Nonce Reuse Attack Explanation](https://billatnapier.medium.com/ecdsa-weakness-where-nonces-are-reused-2be63856a01a)
- [Sony PS3 Hack Technical Details](https://www.schneier.com/blog/archives/2010/12/sony_ps3_securi.html)
- [RFC 6979: Deterministic ECDSA](https://tools.ietf.org/html/rfc6979)
- [Bitcoin Wiki: ECDSA Security](https://en.bitcoin.it/wiki/Elliptic_Curve_Digital_Signature_Algorithm)
